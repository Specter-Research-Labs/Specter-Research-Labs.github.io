<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="color-scheme" content="light" />
        <title>FlowLenia.swift — Struct Parameter Mapping to Flow Lenia Paper | SPECTER Labs</title>
        <link rel="icon" href="../../../assets/logo-black.svg" type="image/svg+xml" />
        <link rel="icon" href="../../../assets/favicon.png" type="image/png" />
        <link rel="stylesheet" href="../../../style.css" />
        <link rel="stylesheet" href="../../../cabinet/cabinet.css" />
    </head>
    <body class="cabinet-page">
        <div class="doc-shell">
            <div class="doc-paper">
                <div class="doc-top">
                    <header class="doc-masthead">
                        <a class="doc-brand" href="../../../">
                            <img
                                src="../../../assets/logo-black.svg"
                                alt="SPECTER Labs logo"
                                class="logo"
                            />
                            <span class="doc-brand-name">SPECTER Labs</span>
                        </a>
                        <div class="doc-markings">
                            <span class="doc-marking">Technical Docs</span>
                                                    </div>
                    </header>
                    <div class="doc-rules" aria-hidden="true">
                        <div class="doc-rule strong"></div>
                        <div class="doc-rule"></div>
                    </div>
                </div>

                <main class="doc-layout">
                    <aside class="doc-aside">
                        <a class="doc-nav-back" href="../../../cabinet/">
                            &larr; Cabinet
                        </a>

                        <div class="doc-stamp">
                                                        <div class="doc-stamp-id">LS-002</div>
                                                        <div class="doc-stamp-title">Lenia Swarm</div>
                                                        <div class="doc-stamp-sub">FlowLenia.swift</div>
                                                                                                                <div class="doc-stamp-field">
                                <strong>Source</strong>
                                <code>dossiers/lenia-swarm/docs/FlowLenia.swift.md</code>
                            </div>
                                                                                    <div class="doc-stamp-field">
                                <strong>Built</strong>
                                2026-02-19T15:28:20Z
                            </div>
                                                    </div>

                                            </aside>

                    <article class="doc-content"><p>FlowLenia.swift — Struct Parameter Mapping to Flow Lenia Paper</p>
<p>Concept This document maps the public structs in <code>Sources/LeniaCore/Core/FlowLenia.swift</code> to the exact equations and line references in the Flow Lenia paper (dossiers/lenia-swarm/lenia-flow-paper.pdf). It is a parameter-to-theory bridge for verifying the Swift implementation against the paper.</p>
<p>Why it matters The Flow Lenia update rule couples convolutional affinity (Lenia) with mass-conserving transport (reintegration tracking). The parameters below are the only user-level knobs that must align with the paper to ensure scientific fidelity, especially when running distributed parameter sweeps.</p>
<p>System connections</p>
<ul>
<li><code>Sources/LeniaCore/Core/FlowLenia.swift</code> (definitions of <code>CompiledKernels</code>, <code>BatchedConfig</code>, and use sites)</li>
<li><code>Sources/LeniaCore/Core/Configuration.swift</code> (runtime config fields that feed <code>BatchedConfig</code>)</li>
<li><code>configs/paper_base_1c_128.json</code> (paper-aligned defaults/ranges)</li>
</ul>
<p>Paper line references (Line numbers refer to PDF text extraction; they are stable for this file but not canonical.)</p>
<ul>
<li>p.2 L100–134: Kernel definition Eq. (1), ring count k=3, growth function Eq. (2), and growth/affinity map Eq. (3).</li>
<li>p.3 L40–69: Flow definition Eq. (5), alpha term with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>A</mi></msub><annotation encoding="application/x-tex">\theta_A</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>, and Sobel gradient note.</li>
<li>p.4 L14–36: Reintegration update Eq. (6–7) and distribution <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">D(m, s)</annotation></semantics></math> with width <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>.</li>
<li>p.4 L70–78: Table 1 with hyperparameters/ranges (includes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">dt</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>, and reintegration temperature <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>).</li>
<li>p.6 L93–105: Chemotaxis channel <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> definition used in the chemotaxis task.</li>
<li>p.7 L35–55: Parameter embedding Eq. (8–10) and mixing rules.</li>
</ul>
<p>Struct: CompiledKernels These fields are compiled, runtime-ready versions of the paper’s kernel and growth definitions.</p>
<ul>
<li>fK
<ul>
<li>Meaning: FFT of the spatial kernels <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>K</mi><mi>i</mi></msub><annotation encoding="application/x-tex">K_i</annotation></semantics></math> used in convolution to compute the affinity map <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mi>t</mi></msub><annotation encoding="application/x-tex">U_t</annotation></semantics></math>.</li>
<li>Paper mapping: Kernel definition Eq. (1) and the statement “K is a set of convolution kernels where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub><mo>:</mo><mi>L</mi><mo>→</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">K_i : L \to [0,1]</annotation></semantics></math>” (p.2 L76). Eq. (3) uses <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub><mo>*</mo><msup><mi>A</mi><mi>t</mi></msup></mrow><annotation encoding="application/x-tex">K_i * A^t</annotation></semantics></math> inside <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mi>t</mi></msub><annotation encoding="application/x-tex">U_t</annotation></semantics></math> (p.2 L125–134).</li>
<li>Controls: Spatial scale/shape of affinity sensing; derived from <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>r</mi><mi>i</mi></msub><mo>,</mo><msub><mi>a</mi><mi>i</mi></msub><mo>,</mo><msub><mi>b</mi><mi>i</mi></msub><mo>,</mo><msub><mi>w</mi><mi>i</mi></msub><mo>,</mo><mi>R</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(r_i, a_i, b_i, w_i, R)</annotation></semantics></math>.</li>
</ul></li>
<li>m
<ul>
<li>Meaning: Per-kernel growth centers <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mu_i</annotation></semantics></math> for the growth function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>G</mi><mi>i</mi></msub><annotation encoding="application/x-tex">G_i</annotation></semantics></math>.</li>
<li>Paper mapping: Growth function Eq. (2) with parameters <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mu_i</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\sigma_i</annotation></semantics></math> (p.2 L114–122).</li>
<li>Controls: Preferred activation level at which growth is maximal.</li>
</ul></li>
<li>s
<ul>
<li>Meaning: Per-kernel growth widths <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\sigma_i</annotation></semantics></math> for the growth function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>G</mi><mi>i</mi></msub><annotation encoding="application/x-tex">G_i</annotation></semantics></math> (not reintegration temperature).</li>
<li>Paper mapping: Same as above (p.2 L114–122).</li>
<li>Controls: How sharply growth falls off around <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mu_i</annotation></semantics></math>.</li>
</ul></li>
<li>h
<ul>
<li>Meaning: Weight vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>∈</mo><msup><mi>ℝ</mi><mrow><mo stretchy="true" form="prefix">|</mo><mi>K</mi><mo stretchy="true" form="postfix">|</mo></mrow></msup></mrow><annotation encoding="application/x-tex">h \in \mathbb{R}^{|K|}</annotation></semantics></math> scaling each kernel–growth pair’s contribution to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mi>t</mi></msub><annotation encoding="application/x-tex">U_t</annotation></semantics></math>.</li>
<li>Paper mapping: “Where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>∈</mo><msup><mi>ℝ</mi><mrow><mo stretchy="true" form="prefix">|</mo><mi>K</mi><mo stretchy="true" form="postfix">|</mo></mrow></msup></mrow><annotation encoding="application/x-tex">h \in \mathbb{R}^{|K|}</annotation></semantics></math> is a vector weighting the importance of each pair <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>K</mi><mi>i</mi></msub><mo>,</mo><msub><mi>G</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(K_i, G_i)</annotation></semantics></math>” (p.3 L08).</li>
<li>Controls: Relative influence of each kernel-growth pair.</li>
</ul></li>
<li>c0Idxs
<ul>
<li>Meaning: Source channel index per kernel; derived from connectivity matrix <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>.</li>
<li>Paper mapping: “Connectivity can be represented through a square adjacency matrix” with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>m</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><annotation encoding="application/x-tex">m_{ij}</annotation></semantics></math> kernels sensing channel <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math> and updating channel <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math> (p.2 L84).</li>
<li>Controls: Which channel each kernel reads from.</li>
</ul></li>
<li>c1Mask
<ul>
<li>Meaning: Target-channel mask for kernels; derived from the same connectivity matrix <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>.</li>
<li>Paper mapping: The indicator term in Eq. (3) (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><msubsup><mi>c</mi><mi>i</mi><mn>1</mn></msubsup><mo>=</mo><mi>j</mi><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[c_i^1 = j]</annotation></semantics></math>) specifies which channel a kernel updates (p.2 L125–134).</li>
<li>Controls: Which channel each kernel writes to.</li>
</ul></li>
</ul>
<p>Struct: BatchedConfig These fields are runtime parameters used to execute the update equations.</p>
<ul>
<li>sx, sy
<ul>
<li>Meaning: Grid dimensions of the lattice <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>.</li>
<li>Paper mapping: Model defined on 2D grid <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ℤ</mi><mn>2</mn></msup><annotation encoding="application/x-tex">\mathbb{Z}^2</annotation></semantics></math> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>t</mi></msup><mo>:</mo><mi>L</mi><mo>→</mo><msup><mi>S</mi><mi>C</mi></msup></mrow><annotation encoding="application/x-tex">A^t : L \to S^C</annotation></semantics></math> (p.2).</li>
<li>Controls: Spatial extent and resolution.</li>
</ul></li>
<li>channels
<ul>
<li>Meaning: Number of channels <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math> (multi-field CA state).</li>
<li>Paper mapping: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>t</mi></msup><mo>:</mo><mi>L</mi><mo>→</mo><msup><mi>S</mi><mi>C</mi></msup></mrow><annotation encoding="application/x-tex">A^t : L \to S^C</annotation></semantics></math> with channel index <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math> (p.2).</li>
<li>Controls: Number of coupled fields; determines size of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>.</li>
</ul></li>
<li>nbK
<ul>
<li>Meaning: Total number of kernels <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">|</mo><mi>K</mi><mo stretchy="true" form="postfix">|</mo></mrow><annotation encoding="application/x-tex">|K|</annotation></semantics></math>, derived from connectivity matrix <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>.</li>
<li>Paper mapping: Same connectivity description (p.2 L84) and Eq. (3) summing over <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">|</mo><mi>K</mi><mo stretchy="true" form="postfix">|</mo></mrow><annotation encoding="application/x-tex">|K|</annotation></semantics></math> kernels (p.2 L125–134).</li>
<li>Controls: Number of kernel–growth pairs used to form <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mi>t</mi></msub><annotation encoding="application/x-tex">U_t</annotation></semantics></math>.</li>
</ul></li>
<li>dt
<ul>
<li>Meaning: Time step <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">dt</annotation></semantics></math>.</li>
<li>Paper mapping: Appears in standard Lenia update Eq. (4) (p.3 L17–21) and in flow transport target <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>″</mi><mo>=</mo><mi>p</mi><mi>′</mi><mo>+</mo><mi>d</mi><mi>t</mi><mo>⋅</mo><msup><mi>F</mi><mi>t</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mi>′</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">p&#39;&#39; = p&#39; + dt\cdot F^t(p&#39;)</annotation></semantics></math> Eq. (7) (p.4 L27–29).</li>
<li>Controls: Integration step size; affects transport distance per step.</li>
</ul></li>
<li>dd
<ul>
<li>Meaning: Discrete window radius for reintegration summation (implementation detail).</li>
<li>Paper mapping: Not explicitly named; it approximates the integral in Eq. (6–7) by summing over nearby offsets (p.4 L14–36).</li>
<li>Controls: Reintegration accuracy vs. cost.</li>
</ul></li>
<li>sigma
<ul>
<li>Meaning: Reintegration distribution width <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">D(m, s)</annotation></semantics></math> (temperature).</li>
<li>Paper mapping: Eq. (7) and the definition “uniform square distribution with side length <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>s</mi></mrow><annotation encoding="application/x-tex">2s</annotation></semantics></math>” (p.4 L31–36); Table 1 lists <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mn>0.65</mn></mrow><annotation encoding="application/x-tex">s=0.65</annotation></semantics></math> (p.4 L74).</li>
<li>Controls: Spatial dispersion of transported mass (diffusion-like smoothing).</li>
</ul></li>
<li>n
<ul>
<li>Meaning: Exponent in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mrow><mo stretchy="true" form="prefix">[</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>A</mi><mi>Σ</mi><mi>t</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mi>θ</mi><mi>A</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup><mo stretchy="true" form="postfix">]</mo></mrow><mn>0</mn><mn>1</mn></msubsup></mrow><annotation encoding="application/x-tex">\alpha(p) = \left[(A^t_\Sigma(p)/\theta_A)^n\right]_0^1</annotation></semantics></math>.</li>
<li>Paper mapping: Eq. (5) (p.3 L40–49) and “We typically use <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n &gt; 1</annotation></semantics></math>” (p.3 L68–69); Table 1 lists <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n=2</annotation></semantics></math> (p.4 L75).</li>
<li>Controls: How quickly mass-gradient dominance increases with mass.</li>
</ul></li>
<li>thetaA
<ul>
<li>Meaning: Critical mass <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>A</mi></msub><annotation encoding="application/x-tex">\theta_A</annotation></semantics></math> for blending affinity and mass gradients.</li>
<li>Paper mapping: Eq. (5) and explanation of “critical mass <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>A</mi></msub><annotation encoding="application/x-tex">\theta_A</annotation></semantics></math>” (p.3 L61–65).</li>
<li>Controls: Mass scale at which diffusion begins to dominate.</li>
</ul></li>
<li>border
<ul>
<li>Meaning: Boundary condition for convolution/gradient operators.</li>
<li>Paper mapping: Not specified in the paper; FFT implementation assumes periodic (torus) boundaries.</li>
<li>Controls: Whether the implementation uses toroidal wrapping or not (implementation constraint).</li>
</ul></li>
<li>colabCompat
<ul>
<li>Meaning: Compatibility switch for the original Colab/JAX implementation (kernel gating/normalization differences).</li>
<li>Paper mapping: Not a paper parameter; implementation detail for parity.</li>
<li>Controls: Reproduces historical reference behavior.</li>
</ul></li>
<li>chemChannel
<ul>
<li>Meaning: Index of the chemotaxis channel <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>.</li>
<li>Paper mapping: Chemotaxis section introduces an external channel <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mo>:</mo><mi>L</mi><mo>→</mo><msub><mi>ℝ</mi><mrow><mo>≥</mo><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\Gamma : L \to \mathbb{R}_{\ge 0}</annotation></semantics></math> (p.6 L93–105).</li>
<li>Controls: Which channel is treated as the chemical field.</li>
</ul></li>
<li>chemIncludeInMass
<ul>
<li>Meaning: Whether <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> contributes to total mass <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>A</mi><mi>Σ</mi><mi>t</mi></msubsup><annotation encoding="application/x-tex">A^t_\Sigma</annotation></semantics></math>.</li>
<li>Paper mapping: The paper treats <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> as external to matter; this flag enforces that (implementation policy).</li>
<li>Controls: Prevents the chemotaxis field from affecting mass conservation.</li>
</ul></li>
</ul>
<p>Notes on parameter symbols</p>
<ul>
<li>Kernel parameters <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>r</mi><mi>i</mi></msub><mo>,</mo><msub><mi>a</mi><mi>i</mi></msub><mo>,</mo><msub><mi>b</mi><mi>i</mi></msub><mo>,</mo><msub><mi>w</mi><mi>i</mi></msub><mo>,</mo><mi>R</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(r_i, a_i, b_i, w_i, R)</annotation></semantics></math> are defined in Eq. (1) (p.2 L100–112).</li>
<li>Growth parameters <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>μ</mi><mi>i</mi></msub><mo>,</mo><msub><mi>σ</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mu_i, \sigma_i)</annotation></semantics></math> are defined in Eq. (2) (p.2 L114–122).</li>
<li>Weight vector <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math> and channel routing are defined in Eq. (3) (p.2 L125–134; p.3 L08).</li>
</ul>
<p>Functions and Classes (Flow Lenia Update Rule) This section maps the remaining functions in <code>FlowLenia.swift</code> to the paper’s equations and described algorithmic steps.</p>
<ul>
<li>growth(U, m, s, h)
<ul>
<li>Meaning: Implements the growth function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">G_i(x)</annotation></semantics></math> and scales by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>h</mi><mi>i</mi></msub><annotation encoding="application/x-tex">h_i</annotation></semantics></math> per kernel-growth pair.</li>
<li>Paper mapping: Eq. (2) defines <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>2</mn><mo>exp</mo><mrow><mo stretchy="true" form="prefix">(</mo><mo>−</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>μ</mi><mi>i</mi></msub><mo>−</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mi>/</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>2</mn><msubsup><mi>σ</mi><mi>i</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">G_i(x) = 2 \exp(-(\mu_i - x)^2 / (2 \sigma_i^2)) - 1</annotation></semantics></math> (p.2 L114–121). Eq. (3) multiplies by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>h</mi><mi>i</mi></msub><annotation encoding="application/x-tex">h_i</annotation></semantics></math> in the construction of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mi>t</mi></msub><annotation encoding="application/x-tex">U_t</annotation></semantics></math> (p.2 L125–134; p.3 L08).</li>
<li>Controls: Shapes the affinity response around <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\mu_i</annotation></semantics></math> with width <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\sigma_i</annotation></semantics></math>, then weights by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>h</mi><mi>i</mi></msub><annotation encoding="application/x-tex">h_i</annotation></semantics></math>.</li>
</ul></li>
<li>sobelBatched / sobelBatchedPeriodic
<ul>
<li>Meaning: Approximates spatial gradients with Sobel filters, in either torus or zero-padded mode.</li>
<li>Paper mapping: “In practice, gradients are estimated through Sobel filtering.” (p.3 L60).</li>
<li>Controls: Numerical gradient estimate for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∇</mi><mi>U</mi></mrow><annotation encoding="application/x-tex">\nabla U</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∇</mi><msub><mi>A</mi><mi>Σ</mi></msub></mrow><annotation encoding="application/x-tex">\nabla A_\Sigma</annotation></semantics></math> in Eq. (5).</li>
</ul></li>
<li>computeFlow(A, …)
<ul>
<li>Meaning: Computes affinity map <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mi>t</mi></msub><annotation encoding="application/x-tex">U_t</annotation></semantics></math> (Lenia), then flow field <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math> combining affinity and mass gradients.</li>
<li>Paper mapping:
<ul>
<li>Eq. (3): <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>U</mi><mi>t</mi></msub><annotation encoding="application/x-tex">U_t</annotation></semantics></math> from convolution <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub><mo>*</mo><msup><mi>A</mi><mi>t</mi></msup></mrow><annotation encoding="application/x-tex">K_i * A^t</annotation></semantics></math> and growth <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>G</mi><mi>i</mi></msub><annotation encoding="application/x-tex">G_i</annotation></semantics></math>, with channel routing and weights <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>h</mi><mi>i</mi></msub><annotation encoding="application/x-tex">h_i</annotation></semantics></math> (p.2 L125–134).</li>
<li>Eq. (5): <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>F</mi><mi>i</mi><mi>t</mi></msubsup><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msup><mi>α</mi><mi>t</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mi>∇</mi><msubsup><mi>U</mi><mi>i</mi><mi>t</mi></msubsup><mo>−</mo><msup><mi>α</mi><mi>t</mi></msup><mi>∇</mi><msubsup><mi>A</mi><mi>Σ</mi><mi>t</mi></msubsup></mrow><annotation encoding="application/x-tex">F^t_i = (1 - \alpha^t)\nabla U^t_i - \alpha^t \nabla A^t_\Sigma</annotation></semantics></math> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>α</mi><mi>t</mi></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mrow><mo stretchy="true" form="prefix">[</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>A</mi><mi>Σ</mi><mi>t</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><msub><mi>θ</mi><mi>A</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mi>n</mi></msup><mo stretchy="true" form="postfix">]</mo></mrow><mn>0</mn><mn>1</mn></msubsup></mrow><annotation encoding="application/x-tex">\alpha^t(p) = [(A^t_\Sigma(p)/\theta_A)^n]_0^1</annotation></semantics></math> (p.3 L40–49).</li>
</ul></li>
<li>Controls: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>θ</mi><mi>A</mi></msub><annotation encoding="application/x-tex">\theta_A</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> govern the transition between affinity-driven and diffusion-like flow; Sobel provides gradient estimates.</li>
<li>Note: <code>massField</code> computes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>A</mi><mi>Σ</mi><mi>t</mi></msubsup><annotation encoding="application/x-tex">A^t_\Sigma</annotation></semantics></math> and can exclude the chemotaxis channel, consistent with treating <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> as external.</li>
</ul></li>
<li>reintegrationBatched(X, F, …)
<ul>
<li>Meaning: Mass-conserving advection via reintegration tracking using a square distribution <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">D(m, s)</annotation></semantics></math> and overlap with cell domains.</li>
<li>Paper mapping:
<ul>
<li>Eq. (6): <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>A</mi><mi>i</mi><mrow><mi>t</mi><mo>+</mo><mi>d</mi><mi>t</mi></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mo>∑</mo><mrow><mi>p</mi><mi>′</mi><mo>∈</mo><mi>L</mi></mrow></msub><msubsup><mi>A</mi><mi>i</mi><mi>t</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mi>′</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>I</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mi>′</mi><mo>,</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A^{t+dt}_i(p) = \sum_{p&#39; \in L} A^t_i(p&#39;) I_i(p&#39;, p)</annotation></semantics></math> (p.4 L14–19).</li>
<li>Eq. (7): <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mi>′</mi><mo>,</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mo>∫</mo><mrow><mi>Ω</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msub><mi>D</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><msub><mi>″</mi><mi>i</mi></msub><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">I_i(p&#39;, p) = \int_{\Omega(p)} D(p&#39;&#39;_i, s)</annotation></semantics></math> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><msub><mi>″</mi><mi>i</mi></msub><mo>=</mo><mi>p</mi><mi>′</mi><mo>+</mo><mi>d</mi><mi>t</mi><mo>⋅</mo><msubsup><mi>F</mi><mi>i</mi><mi>t</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mi>′</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">p&#39;&#39;_i = p&#39; + dt \cdot F^t_i(p&#39;)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math> a uniform square of side <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>s</mi></mrow><annotation encoding="application/x-tex">2s</annotation></semantics></math> (p.4 L21–36).</li>
</ul></li>
<li>Controls: <code>sigma</code> is the distribution width <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math> (temperature), <code>dt</code> scales transport distance, <code>dd</code> is a discrete window radius (implementation detail) used to approximate the integral.</li>
</ul></li>
<li>leniaStepBatched(A, …)
<ul>
<li>Meaning: Full Flow Lenia step: compute <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>F</mi><mi>t</mi></msub><annotation encoding="application/x-tex">F_t</annotation></semantics></math> then reintegrate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>.</li>
<li>Paper mapping: Composition of Eq. (3) + Eq. (5) + Eq. (6–7).</li>
<li>Note: The additive Lenia update Eq. (4) is not used here because Flow Lenia replaces it with mass-conserving transport.</li>
</ul></li>
<li>FlowLeniaBatched, FlowLeniaSimple, leniaStepSingle
<ul>
<li>Meaning: Execution wrappers (batched vs. single) and compilation management; these mirror the paper’s algorithm but add implementation constraints (FFT + loop compilation).</li>
<li>Paper mapping: No direct paper counterpart; they are runtime scaffolding.</li>
</ul></li>
</ul>
<p>Parameter Embedding (Flow Lenia with Local Parameters) The paper extends Flow Lenia by embedding parameters as a spatial field <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>:</mo><mi>L</mi><mo>→</mo><mi>Θ</mi></mrow><annotation encoding="application/x-tex">P : L \to \Theta</annotation></semantics></math> and advecting/mixing them with mass.</p>
<ul>
<li>Parameter embedding in the update rule
<ul>
<li>Paper mapping: Eq. (8) defines a parameter-weighted affinity: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>U</mi><mi>j</mi><mi>t</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mo>∑</mo><mrow><mi>i</mi><mo>,</mo><mi>k</mi></mrow></msub><msubsup><mi>P</mi><mi>k</mi><mi>t</mi></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><msub><mi>G</mi><mi>k</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>K</mi><mi>k</mi></msub><mo>*</mo><msubsup><mi>A</mi><mi>i</mi><mi>t</mi></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">U^t_j(p) = \sum_{i,k} P^t_k(p) \cdot G_k(K_k * A^t_i)(p)</annotation></semantics></math> (p.7 L35–39).</li>
<li>Code mapping: <code>computeFlowWithParams</code> replaces static <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math> with dynamic <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> (per-cell per-kernel weights) before channel routing.</li>
</ul></li>
<li>Mixing rules for parameters
<ul>
<li>Paper mapping:
<ul>
<li>Eq. (9): Weighted average of incoming parameters (p.7 L46–49).</li>
<li>Eq. (10): Softmax sampling from incoming parameters (p.7 L50–55).</li>
</ul></li>
<li>Code mapping:
<ul>
<li><code>reintegrationParamsBatched</code> uses the same reintegration weights for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> and then computes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>P</mi><mrow><mi>t</mi><mo>+</mo><mi>d</mi><mi>t</mi></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">P^{t+dt}(p)</annotation></semantics></math>.</li>
<li><code>mixMode = "avg"</code> implements Eq. (9).</li>
<li><code>mixMode = "softmax"</code> implements Eq. (10) via categorical sampling; <code>mixMode = "stoch"</code> is the same sampling mechanism with explicit seeding.</li>
<li><code>mixMode = "argmax"</code> is implementation-only (not in paper).</li>
</ul></li>
<li>Controls: <code>mixSeed</code> and <code>mixStep</code> drive stochasticity; not specified in the paper but required for reproducibility in distributed runs.</li>
</ul></li>
<li>FlowLeniaParamsBatched and leniaStepParamsBatched
<ul>
<li>Meaning: Full update of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>A</mi><mo>,</mo><mi>P</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(A, P)</annotation></semantics></math> using Eq. (8) for affinity and Eq. (6–7, 9–10) for transport and mixing.</li>
<li>Paper mapping: Combines parameter embedding (p.7 L35–55) with standard Flow Lenia flow/reintegration (p.3–4).</li>
<li>Note: <code>colabCompat</code> alters alpha computation and flow clipping for compatibility; this is not a paper parameter.</li>
</ul></li>
</ul>
<p>Pseudocode Mappings (Equation-by-Equation) The blocks below are simplified, equation-aligned pseudocode for the main kernels. They follow the paper’s ordering and highlight how the Swift code corresponds to each equation.</p>
<ol type="1">
<li>Affinity / Growth (Eq. 1–3)</li>
</ol>
<pre class="text"><code># Inputs: A^t (state), params r,a,b,w,R, mu, sigma, h, connectivity
# Output: U_t (affinity map per channel)

for each kernel i:
  K_i(x) = sum_{j=1..k} b_{i,j} * exp( - ( (x / (r_i R)) - a_{i,j} )^2 / (2 w_{i,j}^2) )   # Eq. (1)

for each kernel i:
  G_i(x) = 2 * exp( - (mu_i - x)^2 / (2 sigma_i^2) ) - 1                                   # Eq. (2)

U_t,j = sum_{i=1..|K|} h_i * G_i( K_i * A^t_{c_i^0} ) * [c_i^1 = j]                         # Eq. (3)</code></pre>
<p>Swift mapping:</p>
<ul>
<li>Kernel creation is in <code>compileKernels</code> (K_i); growth in <code>growth</code>; channel routing in <code>computeFlow</code> (<code>MLX.matmul(G, c1Mask.T)</code>).</li>
</ul>
<ol start="2" type="1">
<li>Flow (Eq. 5)</li>
</ol>
<pre class="text"><code># Inputs: U_t, A^t, theta_A, n
# Output: F_t (flow field per channel)

A^t_Sigma(p) = sum_{i=1..C} A^t_i(p)
alpha(p) = clip( (A^t_Sigma(p) / theta_A)^n, 0, 1 )

F^t_i(p) = (1 - alpha(p)) * grad(U^t_i)(p) - alpha(p) * grad(A^t_Sigma)(p)                  # Eq. (5)</code></pre>
<p>Swift mapping:</p>
<ul>
<li><code>computeFlow</code> computes <code>U</code> then <code>nablaU</code> and <code>nablaA</code> via <code>sobelBatched</code>, and blends them via <code>alpha</code>.</li>
</ul>
<ol start="3" type="1">
<li>Reintegration Tracking (Eq. 6–7)</li>
</ol>
<pre class="text"><code># Inputs: A^t, F^t, dt, s
# Output: A^{t+dt}

p&#39;&#39;_i = p&#39; + dt * F^t_i(p&#39;)                                                                  # Eq. (7)
I_i(p&#39;, p) = ∫_{Omega(p)} D(p&#39;&#39;_i, s)                                                        # Eq. (7)
A^{t+dt}_i(p) = sum_{p&#39; in L} A^t_i(p&#39;) * I_i(p&#39;, p)                                          # Eq. (6)</code></pre>
<p>Swift mapping:</p>
<ul>
<li><code>reintegrationBatched</code> approximates the integral by summing overlaps of the square distribution <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>,</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">D(m, s)</annotation></semantics></math> with each cell. <code>sigma</code> is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>; <code>dd</code> is the discrete window size used for approximation.</li>
</ul>
<ol start="4" type="1">
<li>Full Flow Lenia Step (Eq. 3 + 5 + 6–7)</li>
</ol>
<pre class="text"><code>U_t = affinity(A^t; K, G, h, connectivity)    # Eq. (3)
F_t = flow(U_t, A^t; theta_A, n)              # Eq. (5)
A^{t+dt} = reintegrate(A^t, F_t; dt, s)       # Eq. (6–7)</code></pre>
<p>Swift mapping:</p>
<ul>
<li><code>leniaStepBatched</code> calls <code>computeFlow</code> then <code>reintegrationBatched</code>.</li>
</ul>
<ol start="5" type="1">
<li>Parameter Embedding (Eq. 8–10)</li>
</ol>
<pre class="text"><code># Inputs: A^t, P^t (parameter map), K,G (static), connectivity, mixing rule
# Output: A^{t+dt}, P^{t+dt}

U^t_j(p) = sum_{i,k} P^t_k(p) * G_k( K_k * A^t_i )(p)                                         # Eq. (8)
F^t computed as in Eq. (5) using U^t and A^t

Mixing of P with incoming mass:
P^{t+dt}(p) =  [ sum_{p&#39;} A^t(p&#39;) I(p&#39;,p) P^t(p&#39;) ] / [ sum_{p&#39;} A^t(p&#39;) I(p&#39;,p) ]            # Eq. (9)
or
P[P^{t+dt}(p) = P^t(x)] ∝ exp( A^t(x) I(x,p) )                                                # Eq. (10)</code></pre>
<p>Swift mapping:</p>
<ul>
<li><code>computeFlowWithParams</code> uses per-cell <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> as the weight vector (replacing static <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>) in Eq. (8).</li>
<li><code>reintegrationParamsBatched</code> implements Eq. (9) when <code>mixMode = "avg"</code>, and Eq. (10) when <code>mixMode = "softmax"</code> or <code>"stoch"</code>.</li>
<li><code>mixMode = "argmax"</code> is implementation-only (not in the paper).</li>
</ul>
<p>Implementation Notes (Non-paper Details)</p>
<ul>
<li><code>dd</code> is a discrete approximation window for reintegration; it is not an explicit paper parameter.</li>
<li><code>colabCompat</code> alters kernel gating, alpha computation, and flow clipping to match historical reference code; not in the paper.</li>
<li>FFT-based convolution assumes periodic boundaries; the paper does not specify boundary conditions.</li>
</ul></article>
                </main>

                <footer class="doc-footer">
                    <div class="doc-footer-inner">
                        <div>Specter Labs</div>
                        <div>Lenia Swarm</div>
                    </div>
                </footer>
            </div>
        </div>
    </body>
</html>
